package lib.___exploit___.item;

import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Items;
import net.minecraft.init.MobEffects;
import net.minecraft.item.EnumAction;
import net.minecraft.item.Item;
import net.minecraft.item.ItemFood;
import net.minecraft.item.ItemStack;
import net.minecraft.potion.PotionEffect;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.ObfuscationReflectionHelper;

public class ItemContainedProduct extends ItemFood {
    private final Type type;
    private Item container;
    private boolean isBadFood = false;

    /**
     * @deprecated use {@link ItemContainedProduct#ItemContainedProduct(Type, int, float)}
     */
    @Deprecated
    public ItemContainedProduct(Type type, int amount, float saturation, boolean isWolfFood) {
        super(amount, saturation, isWolfFood);
        this.type = type;
        setContainer(type == Type.DRINK ? Items.GLASS_BOTTLE : Items.BOWL);
        setMaxStackSize(1);
    }

    public ItemContainedProduct(Type type, int amount, float saturation) {
        super(amount, saturation, false);
        this.type = type;
        setContainer(type == Type.DRINK ? Items.GLASS_BOTTLE : Items.BOWL);
        setMaxStackSize(1);
    }

    public ItemContainedProduct(Type type) {
        this(type, 0, 0);
    }

    @Override
    public ItemStack onItemUseFinish(ItemStack stack, World worldIn, EntityLivingBase entityLiving) {
        if (!worldIn.isRemote) {
            if (isBadFood) {
                entityLiving.addPotionEffect(new PotionEffect(MobEffects.HUNGER, 300, 0, false, false));
                entityLiving.addPotionEffect(new PotionEffect(MobEffects.NAUSEA, 300, 0, false, false));
                entityLiving.addPotionEffect(new PotionEffect(MobEffects.POISON, 60, 5, false, false));
            }
            onUsed(stack, worldIn, entityLiving);
        }

        super.onItemUseFinish(stack, worldIn, entityLiving);
        stack.grow(1);
        if (entityLiving instanceof EntityPlayer && !((EntityPlayer) entityLiving).capabilities.isCreativeMode) {
            stack.shrink(1);
        }

        return stack.isEmpty() ? new ItemStack(container) : stack;
    }

    @Override
    public EnumAction getItemUseAction(ItemStack stack) {
        return type == Type.DRINK ? EnumAction.DRINK : EnumAction.EAT;
    }

    /**
     * Item is modified to give hunger, nausea, poison effects when used
     *
     * @return modified item
     */
    public ItemContainedProduct setBadFood() {
        setAlwaysUsable();
        isBadFood = true;
        return this;
    }

    /**
     * Allow eating item by dog
     *
     * @return modified item
     */
    public ItemContainedProduct setWolfFood() {
        ObfuscationReflectionHelper.setPrivateValue(ItemFood.class, this, true, "field_77856_bY"); //isWolfsFavoriteMeat
        return this;
    }

    /**
     * Allow eating item without hunger
     *
     * @return modified item
     */
    public ItemContainedProduct setAlwaysUsable() {
        ObfuscationReflectionHelper.setPrivateValue(ItemFood.class, this, true, "field_77852_bZ"); //alwaysEdible
        return this;
    }

    /**
     * Set container to be given after use
     *
     * @return modified item
     */
    public ItemContainedProduct setContainer(Item container) {
        this.container = container;
        setContainerItem(container);
        return this;
    }

    /**
     * Unset craft container
     *
     * @return modified item
     */
    public ItemContainedProduct setNoCraftContainer() {
        setContainerItem(null);
        return this;
    }

    /**
     * The method is called after the usage is completed
     */
    public void onUsed(ItemStack stack, World worldIn, EntityLivingBase entityLiving) {
    }


    public enum Type {
        DRINK,
        FOOD
    }
}
